{"noir_version":"0.34.0+5598059576c6cbc72474aff4b18bc5e4bb9f08e1","hash":79655022282973574,"abi":{"parameters":[{"name":"id_data","type":{"kind":"struct","path":"utils::IDData","fields":[{"name":"e_content","type":{"kind":"array","length":104,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"encrypted_digest","type":{"kind":"array","length":256,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"mrz","type":{"kind":"string","length":90}},{"name":"dg1_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"dg2_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"dg3_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"dg4_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"dg5_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"dg6_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"dg7_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"dg8_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"dg9_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"dg10_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"dg11_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"dg12_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"dg13_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"dg14_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"dg15_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"dg16_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"current_date","type":{"kind":"string","length":8},"visibility":"public"},{"name":"min_age_required","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"max_age_required","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"70":{"source":"use dep::utils::IDData;\nuse dep::proof_age::proof_of_age;\n\nfn main(\n    id_data: IDData,\n    // The current date is public so verifiers can check the date\n    // provided to the proof is correct\n    current_date: pub str<8>,\n    // The minimum age required is public so verifiers can check\n    // the age provided to the proof is correct\n    min_age_required: pub u8,\n    // The maximum age required is public so verifiers can check\n    // the age provided to the proof is correct\n    // If the maximum age is 0, it is not checked\n    max_age_required: pub u8\n) {\n    // Verify the age of the ID holder\n    proof_of_age(\n        id_data,\n        min_age_required,\n        max_age_required,\n        current_date.as_bytes()\n    );\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/crates/bin/proof/age/src/main.nr"},"71":{"source":"use dep::utils::{\n    PASSPORT_MRZ_LENGTH, PASSPORT_MRZ_BIRTHDATE_INDEX, ID_CARD_MRZ_BIRTHDATE_INDEX, IDData,\n    get_array_slice, is_id_card\n};\nuse dep::date::Date;\n\nfn get_birthdate(id_data: IDData, current_date: [u8; 8]) -> Date {\n    let mut birthdate_bytes = [0 as u8; 6];\n    let mrz_bytes = id_data.mrz.as_bytes();\n\n    // Get the slice of the MRZ representing the birthdate\n    if is_id_card(id_data) {\n        birthdate_bytes = get_array_slice(mrz_bytes, ID_CARD_MRZ_BIRTHDATE_INDEX, ID_CARD_MRZ_BIRTHDATE_INDEX + 6);\n    } else {\n        // Otherwise it's an ID card\n        birthdate_bytes = get_array_slice(mrz_bytes, PASSPORT_MRZ_BIRTHDATE_INDEX, PASSPORT_MRZ_BIRTHDATE_INDEX + 6);\n    }\n\n    // Create a Date object from the birthdate using the current date as\n    // the pivot year to differentiate between 20th and 21st centuries\n    // as the format is \"YYMMDD\"\n    Date::from_bytes_short_year(birthdate_bytes, [current_date[2], current_date[3]])\n}\n\npub fn proof_of_age(id_data: IDData, min_age: u8, max_age: u8, current_date_bytes: [u8; 8]) {\n    let birthdate = get_birthdate(id_data, current_date_bytes);\n\n    let current_date = Date::from_bytes_long_year(current_date_bytes);\n\n    assert((min_age != 0) | (max_age != 0));\n\n    if (min_age != 0) & (max_age == 0) {\n        // Check if age is above min age\n        assert(current_date.gte(birthdate.add_years(min_age as u32)));\n    } else if (max_age != 0) & (min_age == 0) {\n        // Check if age is below max age\n        assert(current_date.lte(birthdate.add_years(max_age as u32)));\n    } else {\n        assert(min_age <= max_age);\n        // Range\n        assert(current_date.gte(birthdate.add_years(min_age as u32)));\n        assert(current_date.lte(birthdate.add_years(max_age as u32)));\n    }\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/crates/lib/proof/age/src/lib.nr"},"72":{"source":"use dep::std::println;\n\nstruct Date {\n    day: u8,\n    month: u8,\n    year: u32,\n}\n\nfn get_number_from_utf8_code(code: u8) -> u8 {\n    assert(code >= 48 & code <= 57);\n    code - 48\n}\n\nfn number_to_utf8_code(number: u8) -> u8 {\n    assert(number >= 0 & number <= 9);\n    number + 48\n}\n\nimpl Date {\n    pub fn new(year: u32, month: u8, day: u8) -> Self {\n        assert(month >= 1 & month <= 12);\n        assert(day >= 1 & day <= 31);\n        let date = Self {\n            day: day,\n            month: month,\n            year: year,\n        };\n        assert(day <= date.get_days_in_month(month));\n        date\n    }\n\n    pub fn from_bytes_short_year(date: [u8; 6], threshold_year: [u8; 2]) -> Self {\n        let firstYearDigit = get_number_from_utf8_code(date[0]);\n        let secondYearDigit = get_number_from_utf8_code(date[1]);\n\n        let mut year: u32 = firstYearDigit as u32 * 10 + secondYearDigit as u32;\n\n        let firstMonthDigit = get_number_from_utf8_code(date[2]);\n        let secondMonthDigit = get_number_from_utf8_code(date[3]);\n\n        let month = firstMonthDigit * 10 + secondMonthDigit;\n\n        let firstDayDigit = get_number_from_utf8_code(date[4]);\n        let secondDayDigit = get_number_from_utf8_code(date[5]);\n\n        let day = firstDayDigit * 10 + secondDayDigit;\n\n        let currentYearFirstDigit = get_number_from_utf8_code(threshold_year[0]);\n        let currentYearSecondDigit = get_number_from_utf8_code(threshold_year[1]);\n\n        let mut currentYear: u32 = currentYearFirstDigit as u32 * 10 + currentYearSecondDigit as u32;\n\n        // This way we have a smooth 100 years period according to a threshold year\n        // Taking the current year as threshold year (for birthdates for example)\n        // if the current year is 2023, then 24 will be interpreted as 1924\n        // while 22 will be interpreted as 2022\n        // A bit problematic for people over 100 years old\n        if year <= currentYear {\n            year += 2000;\n        } else {\n            year += 1900;\n        }\n\n        Self {\n            day: day,\n            month: month,\n            year: year,\n        }\n    }\n\n    pub fn from_bytes_long_year(date: [u8; 8]) -> Self {\n        let firstYearDigit = get_number_from_utf8_code(date[0]);\n        let secondYearDigit = get_number_from_utf8_code(date[1]);\n        let thirdYearDigit = get_number_from_utf8_code(date[2]);\n        let fourthYearDigit = get_number_from_utf8_code(date[3]);\n\n        let year: u32 = firstYearDigit as u32 * 1000 + secondYearDigit as u32 * 100 + thirdYearDigit as u32 * 10 + fourthYearDigit as u32;\n\n        let firstMonthDigit = get_number_from_utf8_code(date[4]);\n        let secondMonthDigit = get_number_from_utf8_code(date[5]);\n\n        let month = firstMonthDigit * 10 + secondMonthDigit;\n\n        let firstDayDigit = get_number_from_utf8_code(date[6]);\n        let secondDayDigit = get_number_from_utf8_code(date[7]);\n\n        let day = firstDayDigit * 10 + secondDayDigit;\n\n        Self {\n            day: day,\n            month: month,\n            year: year,\n        }\n    }\n\n    pub fn from_str_short_year(date: str<6>, threshold_year: str<2>) -> Self {\n        let date_bytes = date.as_bytes();\n        Date::from_bytes_short_year(date_bytes, threshold_year.as_bytes())\n    }\n    \n    pub fn from_str_long_year(date: str<8>) -> Self {\n        let date_bytes = date.as_bytes();\n        Date::from_bytes_long_year(date_bytes)\n    }\n\n    fn get_duration_in_days(self: Self, other: Self, absolute: bool) -> i32 {\n        let totalDuration: i32 = self.get_duration_between_years(other) as i32 \n        + self.get_duration_between_months(other) as i32\n        + (self.day as i32 - other.day as i32);\n\n        if (totalDuration < 0) & absolute {\n            -1 * totalDuration\n        }\n\n        totalDuration\n    }\n\n    fn gt(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) > 0\n    }\n\n    fn lt(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) < 0\n    }\n\n    fn eq(self: Self, other: Self) -> bool {\n        (self.day == other.day) & (self.month == other.month) & (self.year == other.year)\n    }\n\n    fn ne(self: Self, other: Self) -> bool {\n        !self.eq(other)\n    }\n\n    fn gte(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) >= 0\n    }\n\n    fn lte(self: Self, other: Self) -> bool {\n        self.get_duration_in_days(other, false) <= 0\n    }\n\n    fn println(self: Self) {\n        let year = self.year;\n        let month = self.month;\n        let day = self.day;\n        // Let's write the date in the YYYY-MM-DD format\n        // since people don't agree on which format is best\n        // between MM/DD/YYYY and DD/MM/YYYY\n        if (month < 10) & (day < 10) {\n            println(f\"Date: {year}-0{month}-0{day}\");\n        } else if month < 10 {\n            println(f\"Date: {year}-0{month}-{day}\");\n        } else if day < 10 {\n            println(f\"Date: {year}-{month}-0{day}\");\n        } else {\n            println(f\"Date: {year}-{month}-{day}\");\n        }\n    }\n\n    fn to_bytes(self: Self) -> [u8; 8] {\n        let mut date: [u8; 8] = [0; 8];\n\n        let firstYearDigit = self.year / 1000;\n        let secondYearDigit = (self.year - firstYearDigit * 1000) / 100;\n        let thirdYearDigit = (self.year - firstYearDigit * 1000 - secondYearDigit * 100) / 10;\n        let fourthYearDigit = self.year - firstYearDigit * 1000 - secondYearDigit * 100 - thirdYearDigit * 10;\n\n        date[0] = number_to_utf8_code(firstYearDigit as u8);\n        date[1] = number_to_utf8_code(secondYearDigit as u8);\n        date[2] = number_to_utf8_code(thirdYearDigit as u8);\n        date[3] = number_to_utf8_code(fourthYearDigit as u8);\n\n        let firstMonthDigit = self.month / 10;\n        let secondMonthDigit = self.month - firstMonthDigit * 10;\n\n        date[4] = number_to_utf8_code(firstMonthDigit as u8);\n        date[5] = number_to_utf8_code(secondMonthDigit as u8);\n\n        let firstDayDigit = self.day / 10;\n        let secondDayDigit = self.day - firstDayDigit * 10;\n\n        date[6] = number_to_utf8_code(firstDayDigit as u8);\n        date[7] = number_to_utf8_code(secondDayDigit as u8);\n\n        date\n    }\n\n    fn is_leap_year(self: Self) -> bool {\n        self.year % 4 == 0\n    }\n\n    fn get_days_in_month(self: Self, month: u8) -> u8 {\n        assert(month >= 1 & month <= 12);\n        if month == 2 {\n            if self.is_leap_year() {\n                29\n            } else {\n                28\n            }\n        } else {\n            if (month == 1) | (month == 3) | (month == 5) | (month == 7) | (month == 8) | (month == 10) | (month == 12) {\n                31\n            } else {\n                30\n            }\n        }\n    }\n\n    fn get_duration_between_months(self: Self, other: Self) -> i32 {\n        assert(self.month >= 1 & self.month <= 12);\n        assert(other.month >= 1 & other.month <= 12);\n        let mut duration: i32 = 0;\n        if(self.month < other.month) {\n            for month in 1..13 {\n                if month >= self.month & month < other.month {\n                    duration -= other.get_days_in_month(month) as i32;\n                }\n            }\n        } else {\n            for month in 1..13 {\n                if month >= other.month & month < self.month {\n                    duration += self.get_days_in_month(month) as i32;\n                }\n            }\n        }\n        duration\n    }\n\n    fn get_duration_between_years(self: Self, other: Self) -> i32 {\n        let mut duration: i32 = 0;\n        if (self.year < other.year) {\n            let previous_leap_year: u32 = other.year - (other.year % 4);\n            let mut leap_year_count: u32 = 0;\n            if self.year <= previous_leap_year {\n                leap_year_count = (previous_leap_year - self.year) / 4 + 1;\n            }\n            duration -= leap_year_count as i32 * 366;\n            duration -= (other.year as i32 - self.year as i32 - leap_year_count as i32) as i32 * 365;\n        } else if (self.year > other.year) {\n            let next_leap_year: u32 = other.year + (4 - other.year % 4);\n            let mut leap_year_count: u32 = 0;\n            if self.year > next_leap_year {\n                leap_year_count = ((self.year - 1) - next_leap_year) / 4 + 1;\n            }\n            duration += leap_year_count as i32 * 366;\n            duration += (self.year as i32 - other.year as i32 - leap_year_count as i32) as i32 * 365;\n        }\n        duration\n    }\n\n    fn add_years(self: Self, years: u32) -> Self {\n        Self {\n            day: self.day,\n            month: self.month,\n            year: self.year + years,\n        }\n    }\n\n    fn sub_years(self: Self, years: u32) -> Self {\n        Self {\n            day: self.day,\n            month: self.month,\n            year: self.year - years,\n        }\n    }\n\n    fn add_months(self: Self, months: u32) -> Self {\n        let mut newMonth = self.month as u32 + months;\n        let mut newYear = self.year;\n        let yearToAdd = (newMonth - 1) / 12;\n        if newMonth > 12 {\n            newYear += yearToAdd as u32;\n            newMonth -= 12 * yearToAdd;\n        }\n        Self {\n            day: self.day,\n            month: newMonth as u8,\n            year: newYear,\n        }\n    }\n\n    fn sub_months(self: Self, months: u32) -> Self {\n        let mut newMonth = self.month as i32 - months as i32;\n        let mut newYear = self.year;\n        if newMonth < 1 {\n            let yearToSub = ((newMonth as i32 - 12 as i32) * -1) / 12;\n            newYear -= yearToSub as u32;\n            newMonth += 12 * yearToSub;\n        }\n        Self {\n            day: self.day,\n            month: newMonth as u8,\n            year: newYear,\n        }\n    }\n\n    fn add_days(self: Self, days: u32) -> Self {\n        let mut newDay = self.day as u32 + days;\n        let mut newMonth = self.month as u32;\n        let mut newYear = self.year;\n        let mut date = Self {\n            day: newDay as u8,\n            month: newMonth as u8,\n            year: newYear,\n        };\n        if newDay > self.get_days_in_month(self.month) as u32 {\n            let max_months = (newDay / 30) + 1;\n            let bound = self.month + max_months as u8;\n            for _ in self.month..bound {\n                let days_in_month = date.get_days_in_month(newMonth as u8) as u32;\n                if newDay > days_in_month {\n                    newDay -= days_in_month;\n                    newMonth += 1;\n                    if newMonth > 12 {\n                        newYear += 1;\n                        newMonth = 1;\n                    }\n                    // We need to mutate the date object inside the loop \n                    // so we can use get_days_in_month properly\n                    date.day = newDay as u8;\n                    date.year = newYear;\n                    date.month = newMonth as u8;\n                }\n            }\n        }\n        date\n    }\n\n    // Performance could be improved\n    fn sub_days(self: Self, days: u32) -> Self {\n        let mut newDay = self.day as i32 - days as i32;\n        let mut newMonth = self.month as i32;\n        let mut newYear = self.year;\n        let mut date = Self {\n            day: newDay as u8,\n            month: newMonth as u8,\n            year: newYear,\n        };\n        if newDay < 1 {\n            let max_months = (self.day as u32 + days) / 30 + 1;\n            let bound = self.month + max_months as u8;\n            for _ in self.month..bound {\n                let days_in_month = date.get_days_in_month(newMonth as u8) as i32;\n                if newDay < 1 {\n                    newDay += days_in_month;\n                    newMonth -= 1;\n                    if newMonth < 1 {\n                        newYear -= 1;\n                        newMonth = 12;\n                    }\n                    // We need to mutate the date object inside the loop \n                    // so we can use get_days_in_month properly\n                    date.day = newDay as u8;\n                    date.year = newYear;\n                    date.month = newMonth as u8;\n                }\n            }\n        }\n        date\n    }\n}\n\n#[test]\nfn test_date_init() {\n    let date = Date::new(2023, 12, 19);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_bytes_short_year() {\n    let date = Date::from_bytes_short_year([50, 51, 49, 50, 49, 57], [50, 52]);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_bytes_long_year() {\n    let date = Date::from_bytes_long_year([50, 48, 50, 51, 49, 50, 49, 57]);\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_str_short_year() {\n    let date = Date::from_str_short_year(\"231219\", \"24\");\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_from_str_long_year() {\n    let date = Date::from_str_long_year(\"20231219\");\n\n    assert(date.day == 19);\n    assert(date.month == 12);\n    assert(date.year == 2023);\n}\n\n#[test]\nfn test_date_to_bytes() {\n    let date = Date::new(2023, 12, 19);\n\n    let date_bytes = date.to_bytes();\n\n    assert(date_bytes[0] == 50);\n    assert(date_bytes[1] == 48);\n    assert(date_bytes[2] == 50);\n    assert(date_bytes[3] == 51);\n    assert(date_bytes[4] == 49);\n    assert(date_bytes[5] == 50);\n    assert(date_bytes[6] == 49);\n    assert(date_bytes[7] == 57);\n}\n\n#[test]\nfn test_date_is_leap_year() {\n    let date = Date::new(2023, 12, 19);\n\n    assert(date.is_leap_year() == false);\n\n    let date = Date::new(2024, 12, 19);\n\n    assert(date.is_leap_year() == true);\n}\n\n#[test]\nfn test_date_get_days_in_month() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.get_days_in_month(1) == 31);\n    assert(date.get_days_in_month(2) == 28);\n    assert(date.get_days_in_month(3) == 31);\n    assert(date.get_days_in_month(4) == 30);\n    assert(date.get_days_in_month(5) == 31);\n    assert(date.get_days_in_month(6) == 30);\n    assert(date.get_days_in_month(7) == 31);\n    assert(date.get_days_in_month(8) == 31);\n    assert(date.get_days_in_month(9) == 30);\n    assert(date.get_days_in_month(10) == 31);\n    assert(date.get_days_in_month(11) == 30);\n    assert(date.get_days_in_month(12) == 31);\n\n    let date = Date::new(2024, 1, 1);\n\n    assert(date.get_days_in_month(1) == 31);\n    assert(date.get_days_in_month(2) == 29);\n    assert(date.get_days_in_month(3) == 31);\n    assert(date.get_days_in_month(4) == 30);\n    assert(date.get_days_in_month(5) == 31);\n    assert(date.get_days_in_month(6) == 30);\n    assert(date.get_days_in_month(7) == 31);\n    assert(date.get_days_in_month(8) == 31);\n    assert(date.get_days_in_month(9) == 30);\n    assert(date.get_days_in_month(10) == 31);\n    assert(date.get_days_in_month(11) == 30);\n    assert(date.get_days_in_month(12) == 31);\n}\n\n#[test]\nfn test_date_get_duration_between_months() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(Date::new(2023, 1, 1).get_duration_between_months(date) == 0);\n    assert(Date::new(2023, 2, 1).get_duration_between_months(date) == 31);\n    assert(Date::new(2023, 3, 1).get_duration_between_months(date) == 59);\n    assert(Date::new(2023, 4, 1).get_duration_between_months(date) == 90);\n    assert(Date::new(2023, 5, 1).get_duration_between_months(date) == 120);\n    assert(Date::new(2023, 6, 1).get_duration_between_months(date) == 151);\n    assert(Date::new(2023, 7, 1).get_duration_between_months(date) == 181);\n    assert(Date::new(2023, 8, 1).get_duration_between_months(date) == 212);\n    assert(Date::new(2023, 9, 1).get_duration_between_months(date) == 243);\n    assert(Date::new(2023, 10, 1).get_duration_between_months(date) == 273);\n    assert(Date::new(2023, 11, 1).get_duration_between_months(date) == 304);\n    assert(Date::new(2023, 12, 1).get_duration_between_months(date) == 334);\n}\n\n#[test]\nfn test_date_get_duration_between_years() {\n    let date = Date::new(2023, 1, 1);\n\n    // Positive duration\n    assert(Date::new(2023, 1, 1).get_duration_between_years(date) == 0);\n    assert(Date::new(2024, 1, 1).get_duration_between_years(date) == 365);\n    assert(Date::new(2025, 1, 1).get_duration_between_years(date) == 731);\n    assert(Date::new(2026, 1, 1).get_duration_between_years(date) == 1096);\n    assert(Date::new(2027, 1, 1).get_duration_between_years(date) == 1461);\n    assert(Date::new(2028, 1, 1).get_duration_between_years(date) == 1826);\n    assert(Date::new(2029, 1, 1).get_duration_between_years(date) == 2192);\n    assert(Date::new(2030, 1, 1).get_duration_between_years(date) == 2557);\n    assert(Date::new(2031, 1, 1).get_duration_between_years(date) == 2922);\n    assert(Date::new(2032, 1, 1).get_duration_between_years(date) == 3287);\n    assert(Date::new(2033, 1, 1).get_duration_between_years(date) == 3653);\n    assert(Date::new(2034, 1, 1).get_duration_between_years(date) == 4018);\n\n    // Negative duration\n    assert(Date::new(2022, 1, 1).get_duration_between_years(date) == -365);\n    assert(Date::new(2021, 1, 1).get_duration_between_years(date) == -730);\n    assert(Date::new(2020, 1, 1).get_duration_between_years(date) == -1096);\n    assert(Date::new(2019, 1, 1).get_duration_between_years(date) == -1461);\n    assert(Date::new(2018, 1, 1).get_duration_between_years(date) == -1826);\n    assert(Date::new(2017, 1, 1).get_duration_between_years(date) == -2191);\n    assert(Date::new(2016, 1, 1).get_duration_between_years(date) == -2557);\n    assert(Date::new(2015, 1, 1).get_duration_between_years(date) == -2922);\n    assert(Date::new(2014, 1, 1).get_duration_between_years(date) == -3287);\n    assert(Date::new(2013, 1, 1).get_duration_between_years(date) == -3652);\n    assert(Date::new(2012, 1, 1).get_duration_between_years(date) == -4018);\n}\n\n#[test]\nfn test_date_get_duration_in_days() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(Date::new(2023, 1, 1).get_duration_in_days(date, false) == 0);\n    assert(Date::new(2023, 1, 15).get_duration_in_days(date, false) == 14);\n    assert(Date::new(2023, 2, 1).get_duration_in_days(date, false) == 31);\n    assert(Date::new(2023, 2, 15).get_duration_in_days(date, false) == 45);\n    assert(Date::new(2023, 3, 1).get_duration_in_days(date, false) == 59);\n    assert(Date::new(2023, 12, 31).get_duration_in_days(date, false) == 364);\n    assert(Date::new(2024, 1, 1).get_duration_in_days(date, false) == 365);\n    assert(Date::new(2024, 12, 31).get_duration_in_days(date, false) == 365 + 365);\n    assert(Date::new(2025, 1, 1).get_duration_in_days(date, false) == 365 + 366);\n}\n\n#[test]\nfn test_date_eq() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.eq(Date::new(2023, 1, 1)));\n    assert(!date.eq(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_ne() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.ne(Date::new(2023, 1, 1)));\n    assert(date.ne(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_gt() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.gt(Date::new(2023, 1, 1)));\n    assert(!date.gt(Date::new(2023, 1, 2)));\n    assert(date.gt(Date::new(2022, 12, 31)));\n}\n\n#[test]\nfn test_date_lt() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(!date.lt(Date::new(2023, 1, 1)));\n    assert(!date.lt(Date::new(2022, 12, 31)));\n    assert(date.lt(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_gte() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.gte(Date::new(2023, 1, 1)));\n    assert(!date.gte(Date::new(2023, 1, 2)));\n    assert(date.gte(Date::new(2022, 12, 31)));\n}\n\n#[test]\nfn test_date_lte() {\n    let date = Date::new(2023, 1, 1);\n\n    assert(date.lte(Date::new(2023, 1, 1)));\n    assert(!date.lte(Date::new(2022, 12, 31)));\n    assert(date.lte(Date::new(2023, 1, 2)));\n}\n\n#[test]\nfn test_date_add_years() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_years(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_years(1).eq(Date::new(2024, 7, 14)));\n    assert(date.add_years(2).eq(Date::new(2025, 7, 14)));\n    assert(date.add_years(3).eq(Date::new(2026, 7, 14)));\n    assert(date.add_years(4).eq(Date::new(2027, 7, 14)));\n    assert(date.add_years(5).eq(Date::new(2028, 7, 14)));\n}\n\n#[test]\nfn test_date_sub_years() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_years(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_years(1).eq(Date::new(2022, 7, 14)));\n    assert(date.sub_years(2).eq(Date::new(2021, 7, 14)));\n    assert(date.sub_years(3).eq(Date::new(2020, 7, 14)));\n    assert(date.sub_years(4).eq(Date::new(2019, 7, 14)));\n    assert(date.sub_years(5).eq(Date::new(2018, 7, 14)));\n}\n\n#[test]\nfn test_date_add_months() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_months(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_months(1).eq(Date::new(2023, 8, 14)));\n    assert(date.add_months(2).eq(Date::new(2023, 9, 14)));\n\n    assert(date.add_months(6).eq(Date::new(2024, 1, 14)));\n    assert(date.add_months(7).eq(Date::new(2024, 2, 14)));\n    assert(date.add_months(8).eq(Date::new(2024, 3, 14)));\n\n    assert(date.add_months(17).eq(Date::new(2024, 12, 14)));\n    assert(date.add_months(18).eq(Date::new(2025, 1, 14)));\n\n    assert(date.add_months(29).eq(Date::new(2025, 12, 14)));\n    assert(date.add_months(30).eq(Date::new(2026, 1, 14)));\n}\n\n#[test]\nfn test_date_sub_months() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_months(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_months(1).eq(Date::new(2023, 6, 14)));\n    assert(date.sub_months(2).eq(Date::new(2023, 5, 14)));\n\n    assert(date.sub_months(6).eq(Date::new(2023, 1, 14)));\n    assert(date.sub_months(7).eq(Date::new(2022, 12, 14)));\n    assert(date.sub_months(8).eq(Date::new(2022, 11, 14)));\n\n    assert(date.sub_months(17).eq(Date::new(2022, 2, 14)));\n    assert(date.sub_months(18).eq(Date::new(2022, 1, 14)));\n    assert(date.sub_months(19).eq(Date::new(2021, 12, 14)));\n\n    assert(date.sub_months(30).eq(Date::new(2021, 1, 14)));\n    assert(date.sub_months(31).eq(Date::new(2020, 12, 14)));\n\n    assert(date.sub_months(41).eq(Date::new(2020, 2, 14)));\n    assert(date.sub_months(42).eq(Date::new(2020, 1, 14)));\n    assert(date.sub_months(43).eq(Date::new(2019, 12, 14)));\n}\n\n#[test]\nfn test_date_add_days() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.add_days(0).eq(Date::new(2023, 7, 14)));\n    assert(date.add_days(1).eq(Date::new(2023, 7, 15)));\n    assert(date.add_days(2).eq(Date::new(2023, 7, 16)));\n\n    assert(date.add_days(17).eq(Date::new(2023, 7, 31)));\n    assert(date.add_days(18).eq(Date::new(2023, 8, 1)));\n    assert(date.add_days(19).eq(Date::new(2023, 8, 2)));\n\n    assert(date.add_days(31).eq(Date::new(2023, 8, 14)));\n    assert(date.add_days(32).eq(Date::new(2023, 8, 15)));\n    assert(date.add_days(33).eq(Date::new(2023, 8, 16)));\n\n    assert(date.add_days(365).eq(Date::new(2024, 7, 13)));\n    assert(date.add_days(366).eq(Date::new(2024, 7, 14)));\n    assert(date.add_days(367).eq(Date::new(2024, 7, 15)));\n\n    assert(date.add_days(365 + 365).eq(Date::new(2025, 7, 13)));\n    assert(date.add_days(365 + 366).eq(Date::new(2025, 7, 14)));\n    assert(date.add_days(365 + 367).eq(Date::new(2025, 7, 15)));\n\n    assert(date.add_days(365 + 366 + 364).eq(Date::new(2026, 7, 13)));\n    assert(date.add_days(365 + 366 + 365).eq(Date::new(2026, 7, 14)));\n    assert(date.add_days(365 + 366 + 366).eq(Date::new(2026, 7, 15)));\n\n    // After 4 regular years and 2 leap years\n    assert(date.add_days(365 * 4 + 366 * 2 - 1).eq(Date::new(2029, 7, 13)));\n    assert(date.add_days(365 * 4 + 366 * 2).eq(Date::new(2029, 7, 14)));\n    assert(date.add_days(365 * 4 + 366 * 2 + 1).eq(Date::new(2029, 7, 15)));\n}\n\n#[test]\nfn test_date_sub_days() {\n    let date = Date::new(2023, 7, 14);\n\n    assert(date.sub_days(0).eq(Date::new(2023, 7, 14)));\n    assert(date.sub_days(1).eq(Date::new(2023, 7, 13)));\n    assert(date.sub_days(2).eq(Date::new(2023, 7, 12)));\n\n    assert(date.sub_days(17).eq(Date::new(2023, 6, 28)));\n    assert(date.sub_days(18).eq(Date::new(2023, 6, 27)));\n    assert(date.sub_days(19).eq(Date::new(2023, 6, 26)));\n\n    assert(date.sub_days(31).eq(Date::new(2023, 6, 14)));\n    assert(date.sub_days(32).eq(Date::new(2023, 6, 13)));\n    assert(date.sub_days(33).eq(Date::new(2023, 6, 12)));\n\n    assert(date.sub_days(365).eq(Date::new(2022, 7, 14)));\n    assert(date.sub_days(366).eq(Date::new(2022, 7, 13)));\n    assert(date.sub_days(367).eq(Date::new(2022, 7, 12)));\n\n    assert(date.sub_days(365 + 365).eq(Date::new(2021, 7, 14)));\n    assert(date.sub_days(365 + 366).eq(Date::new(2021, 7, 13)));\n    assert(date.sub_days(365 + 367).eq(Date::new(2021, 7, 12)));\n\n    assert(date.sub_days(365 + 365 + 365).eq(Date::new(2020, 7, 14)));\n    assert(date.sub_days(365 + 365 + 366).eq(Date::new(2020, 7, 13)));\n    assert(date.sub_days(365 + 365 + 367).eq(Date::new(2020, 7, 12)));\n\n    // After 5 regular years and 1 leap year\n    assert(date.sub_days(365 * 5 + 366 - 1).eq(Date::new(2017, 7, 15)));\n    assert(date.sub_days(365 * 5 + 366).eq(Date::new(2017, 7, 14)));\n    assert(date.sub_days(365 * 5 + 366 + 1).eq(Date::new(2017, 7, 13)));\n\n    // After 6 regular years and 2 leap years\n    assert(date.sub_days(365 * 6 + 366 * 2 - 1).eq(Date::new(2015, 7, 15)));\n    assert(date.sub_days(365 * 6 + 366 * 2).eq(Date::new(2015, 7, 14)));\n    assert(date.sub_days(365 * 6 + 366 * 2 + 1).eq(Date::new(2015, 7, 13)));\n}\n\n#[test]\nfn test_date_age() {\n    let birthdate = Date::new(1995, 4, 13);\n\n    // Add 18 years to the birthdate\n    // to get the date when the person is 18 years old\n    let majority_date = birthdate.add_years(18);\n\n    // Make sure the majority date is correct\n    assert(majority_date.eq(Date::new(2013, 4, 13)));\n\n    // Compare the majority date to the current date\n    // to see if the person is 18 years old\n    assert(majority_date.lte(Date::new(2023, 12, 20)));\n}\n","path":"/Users/madztheo/nargo/github.com/madztheo/noir-date.git0.4.2/src/lib.nr"},"73":{"source":"/**\n* The standards for passports and any other travel documents, electronic or not,\n* are defined in the ICAO (International Civil Aviation Organization) 9303 document available here: \n* https://www.icao.int/publications/pages/publication.aspx?docnum=9303\n*/\n\n/**\n* The structure of the MRZ is well defined and standardized by the ICAO\n* so the index will always be the same for every passport\n* c.f. ICAO 9303-4, Appendix B\n*/\n\n// The following constants define the indices of the information\n// we need to generate various proofs of identity from the MRZ\n// The structure of the MRZ is slightly different between passports\n// and ID cards so we need to define indices for both types\n\n// Index for the country of issuance of the passport\nglobal PASSPORT_MRZ_COUNTRY_INDEX: u32 = 2;\n// Index for the three letter code of the country of citizenship\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits \n// where the issuing country differs from the citizenship country\nglobal PASSPORT_MRZ_NATIONALITY_INDEX: u32 = 54;\n// Index for the sex of the passport holder (M, F or < if unspecified)\nglobal PASSPORT_MRZ_SEX_INDEX: u32 = 64;\n// Index for the date of expiry (YYMMDD)\nglobal PASSPORT_MRZ_EXPIRY_DATE_INDEX: u32 = 65;\n// Index for the date of birth (YYMMDD) in TD1 (i.e. passport) MRZ\nglobal PASSPORT_MRZ_BIRTHDATE_INDEX: u32 = 57;\n// Index for the document number in the MRZ\nglobal PASSPORT_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 44;\n// Index for the document type in the MRZ\nglobal PASSPORT_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\nglobal PASSPORT_MRZ_NAME_INDEX: u32 = 5;\n// Length of the MRZ on a passport\nglobal PASSPORT_MRZ_LENGTH: u32 = 88;\n\n// Index for the country of issuance of the ID card\nglobal ID_CARD_MRZ_COUNTRY_INDEX: u32 = 2;\n// Note that the first three letter code (index 2) in the MRZ is the country of issuance\n// not citizenship. It is important to keep in mind for residence permits \n// where the issuing country differs from the citizenship country\nglobal ID_CARD_MRZ_NATIONALITY_INDEX: u32 = 45;\n// Index for the sex of the passport holder (M, F or < if unspecified)\nglobal ID_CARD_MRZ_SEX_INDEX: u32 = 37;\n// Index for the date of expiry (YYMMDD)\nglobal ID_CARD_MRZ_EXPIRY_DATE_INDEX: u32 = 38;\n// Index for the date of birth (YYMMDD) in TD3 (i.e. ID cards) MRZ\nglobal ID_CARD_MRZ_BIRTHDATE_INDEX: u32 = 30;\n// Index for the document number in the MRZ\nglobal ID_CARD_MRZ_DOCUMENT_NUMBER_INDEX: u32 = 5;\n// Index for the document type in the MRZ\nglobal ID_CARD_MRZ_DOCUMENT_TYPE_INDEX: u32 = 0;\n// Index for the name of the passport holder\nglobal ID_CARD_MRZ_NAME_INDEX: u32 = 60;\n// Length of the MRZ on an ID card\nglobal ID_CARD_MRZ_LENGTH: u32 = 90;\n\nstruct IDData {\n    // Last 32 bytes: result of the hash of all the hashes of the data groups\n    // Rest of the bytes: padding data + signature date\n    e_content: [u8; 104],\n    // The signature of the ID data, essentially the signature by the private\n    // key of the Document Signing Certificate (DSC) of the ID over e_content\n    encrypted_digest: [u8; 256],\n    // The Machine Readable Zone (MRZ) of the document\n    // The two lines at the bottom of the passport data page\n    // or the three bottom lines on the rear of an ID card\n    mrz: str<90>,\n\n    // The hashes of each data group\n    // While the hashing algorithm could be any SHA, we assume it's SHA-256\n    // for now as is the case for French passports\n    // Only DG1 and DG2 are mandatory\n    // The others are optional (or conditional under certain circumstances)\n    // If not present in the ID, the array shall be filled with 0s\n\n    // Data Group 1 -> Contains the MRZ (Machine Readable Zone)\n    dg1_hash: [u8; 32],\n    // Data Group 2 -> Contains the photo of the ID holder\n    dg2_hash: [u8; 32],\n    // Data Group 3 -> Contains the fingerprints of the ID holder (access likely restricted)\n    dg3_hash: [u8; 32],\n    // Data Group 4 -> Contains the iris scan of the ID holder (access likely restricted)\n    dg4_hash: [u8; 32],\n    // Data Group 5 -> Contains the displayed portrait\n    dg5_hash: [u8; 32],\n    // Data Group 6 -> Reserved for future use (so not used as of today)\n    dg6_hash: [u8; 32],\n    // Data Group 7 -> Contains the displayed signature\n    dg7_hash: [u8; 32],\n    // Data Group 8 -> Yet to be defined, can be used for temporary proprietary usage\n    dg8_hash: [u8; 32],\n    // Data Group 9 -> Yet to be defined, can be used for temporary proprietary usage\n    dg9_hash: [u8; 32],\n    // Data Group 10 -> Yet to be defined, can be used for temporary proprietary usage\n    dg10_hash: [u8; 32],\n    // Data Group 11 -> Contains additional personal details (such as the address, full date of birth, etc.)\n    dg11_hash: [u8; 32],\n    // Data Group 12 -> Contains additional document details (such as date of issue, issuing authority, etc.)\n    dg12_hash: [u8; 32],\n    // Data Group 13 -> Freeform data group where each State can fully decide of the data in it and how to encode them\n    dg13_hash: [u8; 32],\n    // Data Group 14 -> Contains security options for authentication with the chip of the ID\n    dg14_hash: [u8; 32],\n    // Data Group 15 -> Contains the Active Authentication Public Key Info\n    dg15_hash: [u8; 32],\n    // Data Group 16 -> Contains the details of the persons to notify (i.e. emergency contacts)\n    dg16_hash: [u8; 32],\n}\n\nstruct DSCData {\n    // The public key of the Document Signing Certificate (DSC)\n    // Most likely a 2048-bit RSA key, so that's the size we set here\n    // 256 bytes = 2048 bits\n    pubkey: [u8; 256],\n    // In the case of RSA, this is the public exponent (most often either 65537 or 3)\n    exponent: u32,\n    // The signature of the DSC TBS certificate by the CSCA certificate\n    // 512 bytes = 4096 bits\n    signature: [u8; 512],\n    // The TBS certificate of the DSC\n    // TBS stands for To Be Signed\n    tbs_certificate: [u8; 888],\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    redc_param: [u8; 257],\n}\n\nstruct CSCACertData {\n    // The public key of the Country Signing Certificate Authority (CSCA)\n    // Most likely a 4096-bit RSA key, so that's the size we set here\n    // 512 bytes = 4096 bits\n    pubkey: [u8; 512],\n    // Data used to verify the signature\n    // Generated by the pre-compute function in Rust\n    // c.f. main.rs\n    redc_param: [Field; 35],\n    exponent: u32,\n}\n\nstruct DiscloseFlags {\n    issuing_country: bool,\n    nationality: bool,\n    document_type: bool,\n    document_number: bool,\n    date_of_expiry: bool,\n    date_of_birth: bool,\n    sex: bool,\n    name: bool,\n}\n\nstruct DisclosedData {\n    issuing_country: [u8; 3],\n    nationality: [u8; 3],\n    document_type: [u8; 2],\n    document_number: [u8; 9],\n    date_of_expiry: [u8; 6],\n    date_of_birth: [u8; 6],  \n    name: [u8; 39],\n}\n\npub fn get_array_slice<let N: u32, let M: u32>(arr: [u8; N], start: u32, end: u32) -> [u8; M] {\n    let mut slice = [0 as u8; M];\n    for i in start..end {\n        slice[i - start] = arr[i];\n    }\n    slice\n}\n\n// Reverse the bytes of an array so you can switch from\n// big endian to little endian order and vice versa\npub fn reverse_bytes_array<let N: u32>(arr: [u8; N]) -> [u8; N] {\n    let mut reversed_arr = [0 as u8; N];\n    for i in 0..N {\n        // Reverse\n        reversed_arr[i] = arr[N - 1 - i];\n    }\n    reversed_arr\n}\n\npub fn insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32\n) -> [u8; N] {\n    for i in index..index + M {\n        arr[i] = sub_arr[i - index];\n    }\n    arr\n}\n\npub fn dynamic_insert_into_array<let N: u32, let M: u32>(\n    mut arr: [u8; N],\n    sub_arr: [u8; M],\n    index: u32,\n    max_size: u32\n) -> [u8; N] {\n    for i in index..index + max_size {\n        if i - index < M {\n            arr[i] = sub_arr[i - index];\n        }\n    }\n    arr\n}\n\n/**\n* Rather hacky but in some cases we cannot use a for loop as the compiler \n* won't be able to determine its bounds at compile time\n*/\npub fn insert_32_bytes_into_array<let N: u32>(mut arr: [u8; N], sub_arr: [u8; 32], index: u32) -> [u8; N] {\n    arr[index] = sub_arr[0];\n    arr[index + 1] = sub_arr[1];\n    arr[index + 2] = sub_arr[2];\n    arr[index + 3] = sub_arr[3];\n    arr[index + 4] = sub_arr[4];\n    arr[index + 5] = sub_arr[5];\n    arr[index + 6] = sub_arr[6];\n    arr[index + 7] = sub_arr[7];\n    arr[index + 8] = sub_arr[8];\n    arr[index + 9] = sub_arr[9];\n    arr[index + 10] = sub_arr[10];\n\n    arr[index + 11] = sub_arr[11];\n    arr[index + 12] = sub_arr[12];\n    arr[index + 13] = sub_arr[13];\n    arr[index + 14] = sub_arr[14];\n    arr[index + 15] = sub_arr[15];\n    arr[index + 16] = sub_arr[16];\n    arr[index + 17] = sub_arr[17];\n    arr[index + 18] = sub_arr[18];\n    arr[index + 19] = sub_arr[19];\n    arr[index + 20] = sub_arr[20];\n\n    arr[index + 21] = sub_arr[21];\n    arr[index + 22] = sub_arr[22];\n    arr[index + 23] = sub_arr[23];\n    arr[index + 24] = sub_arr[24];\n    arr[index + 25] = sub_arr[25];\n    arr[index + 26] = sub_arr[26];\n    arr[index + 27] = sub_arr[27];\n    arr[index + 28] = sub_arr[28];\n    arr[index + 29] = sub_arr[29];\n    arr[index + 30] = sub_arr[30];\n\n    arr[index + 31] = sub_arr[31];\n\n    arr\n}\n\npub fn insert_7_bytes_into_array<let N: u32>(mut arr: [u8; N], sub_arr: [u8; 7], index: u32) -> [u8; N] {\n    arr[index] = sub_arr[0];\n    arr[index + 1] = sub_arr[1];\n    arr[index + 2] = sub_arr[2];\n    arr[index + 3] = sub_arr[3];\n    arr[index + 4] = sub_arr[4];\n    arr[index + 5] = sub_arr[5];\n    arr[index + 6] = sub_arr[6];\n    arr\n}\n\npub fn is_id_card(id_data: IDData) -> bool {\n    let mrz_bytes = id_data.mrz.as_bytes();\n    // 95 encodes the _ character\n    // This is our padding character to support both the \n    // MRZ of the passports and ID cards\n    (mrz_bytes[88] != 95) & (mrz_bytes[89] != 95)\n}\n\npub fn from_byte_be_to_fields<let NBytes: u32, let N: u32>(x: [u8; NBytes]) -> [Field; N] {\n    let mut result = [0 as Field; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    result\n}\n\nunconstrained pub fn __from_byte_be_to_fields<let NBytes: u32, let N: u32>(x: [u8; NBytes]) -> [Field; N] {\n    from_byte_be_to_fields(x)\n}\n","path":"/Users/madztheo/Documents/Wagmi/Studio/RnD/Docaproof/Circuits/zk_id_check_circuits/crates/lib/utils/src/lib.nr"}},"names":["main"],"brillig_names":["directive_invert","directive_integer_quotient"]}